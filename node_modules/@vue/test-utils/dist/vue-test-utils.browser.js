
/**
 * @vue/test-utils v2.0.0-alpha.5
 * (c) 2020 Lachlan Miller
 * Released under the MIT License
 */

var VueTestUtils = (function (exports, vue, compilerDom) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var Pluggable = /** @class */ (function () {
        function Pluggable() {
            this.installedPlugins = [];
        }
        Pluggable.prototype.install = function (handler, options) {
            if (options === void 0) { options = {}; }
            if (typeof handler !== 'function') {
                console.error('plugin.install must receive a function');
                handler = function () { return ({}); };
            }
            this.installedPlugins.push({ handler: handler, options: options });
        };
        Pluggable.prototype.extend = function (instance) {
            var invokeSetup = function (plugin) { return plugin.handler(instance); }; // invoke the setup method passed to install
            var bindProperty = function (_a) {
                var property = _a[0], value = _a[1];
                instance[property] =
                    typeof value === 'function' ? value.bind(instance) : value;
            };
            var addAllPropertiesFromSetup = function (setupResult) {
                setupResult = typeof setupResult === 'object' ? setupResult : {};
                Object.entries(setupResult).forEach(bindProperty);
            };
            this.installedPlugins.map(invokeSetup).forEach(addAllPropertiesFromSetup);
        };
        /** For testing */
        Pluggable.prototype.reset = function () {
            this.installedPlugins = [];
        };
        return Pluggable;
    }());
    var config = {
        global: {},
        plugins: {
            VueWrapper: new Pluggable(),
            DOMWrapper: new Pluggable()
        },
        renderStubDefaultSlot: false
    };

    function mergeStubs(target, source) {
        if (source.stubs) {
            if (Array.isArray(source.stubs)) {
                source.stubs.forEach(function (x) { return (target[x] = true); });
            }
            else {
                for (var _i = 0, _a = Object.entries(source.stubs); _i < _a.length; _i++) {
                    var _b = _a[_i], k = _b[0], v = _b[1];
                    target[k] = v;
                }
            }
        }
    }
    function mergeGlobalProperties(configGlobal, mountGlobal) {
        if (configGlobal === void 0) { configGlobal = {}; }
        if (mountGlobal === void 0) { mountGlobal = {}; }
        var stubs = {};
        mergeStubs(stubs, configGlobal);
        mergeStubs(stubs, mountGlobal);
        return {
            mixins: __spreadArrays((configGlobal.mixins || []), (mountGlobal.mixins || [])),
            plugins: __spreadArrays((configGlobal.plugins || []), (mountGlobal.plugins || [])),
            stubs: stubs,
            components: __assign(__assign({}, configGlobal.components), mountGlobal.components),
            provide: __assign(__assign({}, configGlobal.provide), mountGlobal.provide),
            mocks: __assign(__assign({}, configGlobal.mocks), mountGlobal.mocks),
            config: __assign(__assign({}, configGlobal.config), mountGlobal.config),
            directives: __assign(__assign({}, configGlobal.directives), mountGlobal.directives)
        };
    }

    function processSlot(template, Vue) {
        if (template === void 0) { template = ''; }
        if (Vue === void 0) { Vue = require('vue'); }
        var hasWrappingTemplate = template && template.startsWith('<template');
        // allow content without `template` tag, for easier testing
        if (!hasWrappingTemplate) {
            template = "<template #default=\"params\">" + template + "</template>";
        }
        var code = compilerDom.compile("<SlotWrapper v-bind=\"$attrs\">" + template + "</SlotWrapper>", {
            mode: 'function',
            prefixIdentifiers: true
        }).code;
        var createRenderFunction = new Function('Vue', "'use strict';\n" + code);
        return {
            inheritAttrs: false,
            render: createRenderFunction(Vue),
            components: {
                SlotWrapper: {
                    inheritAttrs: false,
                    setup: function (_, _a) {
                        var slots = _a.slots, attrs = _a.attrs;
                        return function () {
                            var names = Object.keys(slots);
                            if (names.length === 0) {
                                return [];
                            }
                            else {
                                var slotName = names[0];
                                return slots[slotName](attrs);
                            }
                        };
                    }
                }
            }
        };
    }

    function createWrapperError(wrapperType) {
        return new Proxy(Object.create(null), {
            get: function (obj, prop) {
                switch (prop) {
                    case 'exists':
                        return function () { return false; };
                    default:
                        throw new Error("Cannot call " + String(prop) + " on an empty " + wrapperType + ".");
                }
            }
        });
    }

    var abort = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var afterprint = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var animationend = {
    	eventInterface: "AnimationEvent",
    	bubbles: true,
    	cancelable: false
    };
    var animationiteration = {
    	eventInterface: "AnimationEvent",
    	bubbles: true,
    	cancelable: false
    };
    var animationstart = {
    	eventInterface: "AnimationEvent",
    	bubbles: true,
    	cancelable: false
    };
    var appinstalled = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var audioprocess = {
    	eventInterface: "AudioProcessingEvent"
    };
    var audioend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var audiostart = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var beforeprint = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var beforeunload = {
    	eventInterface: "BeforeUnloadEvent",
    	bubbles: false,
    	cancelable: true
    };
    var beginEvent = {
    	eventInterface: "TimeEvent",
    	bubbles: false,
    	cancelable: false
    };
    var blur = {
    	eventInterface: "FocusEvent",
    	bubbles: false,
    	cancelable: false
    };
    var boundary = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var cached = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var canplay = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var canplaythrough = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var change = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var chargingchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var chargingtimechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var checking = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var click = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var close = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var complete = {
    	eventInterface: "OfflineAudioCompletionEvent"
    };
    var compositionend = {
    	eventInterface: "CompositionEvent",
    	bubbles: true,
    	cancelable: true
    };
    var compositionstart = {
    	eventInterface: "CompositionEvent",
    	bubbles: true,
    	cancelable: true
    };
    var compositionupdate = {
    	eventInterface: "CompositionEvent",
    	bubbles: true,
    	cancelable: false
    };
    var contextmenu = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var copy = {
    	eventInterface: "ClipboardEvent"
    };
    var cut = {
    	eventInterface: "ClipboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dblclick = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var devicechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var devicelight = {
    	eventInterface: "DeviceLightEvent",
    	bubbles: false,
    	cancelable: false
    };
    var devicemotion = {
    	eventInterface: "DeviceMotionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var deviceorientation = {
    	eventInterface: "DeviceOrientationEvent",
    	bubbles: false,
    	cancelable: false
    };
    var deviceproximity = {
    	eventInterface: "DeviceProximityEvent",
    	bubbles: false,
    	cancelable: false
    };
    var dischargingtimechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var DOMActivate = {
    	eventInterface: "UIEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMAttributeNameChanged = {
    	eventInterface: "MutationNameEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMAttrModified = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMCharacterDataModified = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMContentLoaded = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var DOMElementNameChanged = {
    	eventInterface: "MutationNameEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMFocusIn = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMFocusOut = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeInserted = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeInsertedIntoDocument = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeRemoved = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeRemovedFromDocument = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMSubtreeModified = {
    	eventInterface: "MutationEvent"
    };
    var downloading = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var drag = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dragend = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: false
    };
    var dragenter = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dragleave = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: false
    };
    var dragover = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dragstart = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var drop = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var durationchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var emptied = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var end = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var ended = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var endEvent = {
    	eventInterface: "TimeEvent",
    	bubbles: false,
    	cancelable: false
    };
    var error = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var focus = {
    	eventInterface: "FocusEvent",
    	bubbles: false,
    	cancelable: false
    };
    var focusin = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: false
    };
    var focusout = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: false
    };
    var fullscreenchange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var fullscreenerror = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var gamepadconnected = {
    	eventInterface: "GamepadEvent",
    	bubbles: false,
    	cancelable: false
    };
    var gamepaddisconnected = {
    	eventInterface: "GamepadEvent",
    	bubbles: false,
    	cancelable: false
    };
    var gotpointercapture = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var hashchange = {
    	eventInterface: "HashChangeEvent",
    	bubbles: true,
    	cancelable: false
    };
    var lostpointercapture = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var input = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var invalid = {
    	eventInterface: "Event",
    	cancelable: true,
    	bubbles: false
    };
    var keydown = {
    	eventInterface: "KeyboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var keypress = {
    	eventInterface: "KeyboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var keyup = {
    	eventInterface: "KeyboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var languagechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var levelchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var load = {
    	eventInterface: "UIEvent",
    	bubbles: false,
    	cancelable: false
    };
    var loadeddata = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var loadedmetadata = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var loadend = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var loadstart = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mark = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var message = {
    	eventInterface: "MessageEvent",
    	bubbles: false,
    	cancelable: false
    };
    var messageerror = {
    	eventInterface: "MessageEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mousedown = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseenter = {
    	eventInterface: "MouseEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mouseleave = {
    	eventInterface: "MouseEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mousemove = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseout = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseover = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseup = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var nomatch = {
    	eventInterface: "SpeechRecognitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var notificationclick = {
    	eventInterface: "NotificationEvent",
    	bubbles: false,
    	cancelable: false
    };
    var noupdate = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var obsolete = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var offline = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var online = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var open = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var orientationchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var pagehide = {
    	eventInterface: "PageTransitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pageshow = {
    	eventInterface: "PageTransitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var paste = {
    	eventInterface: "ClipboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pause = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pointercancel = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: false
    };
    var pointerdown = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerenter = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pointerleave = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pointerlockchange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var pointerlockerror = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var pointermove = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerout = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerover = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerup = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var play = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var playing = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var popstate = {
    	eventInterface: "PopStateEvent",
    	bubbles: true,
    	cancelable: false
    };
    var progress = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var push = {
    	eventInterface: "PushEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pushsubscriptionchange = {
    	eventInterface: "PushEvent",
    	bubbles: false,
    	cancelable: false
    };
    var ratechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var readystatechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var repeatEvent = {
    	eventInterface: "TimeEvent",
    	bubbles: false,
    	cancelable: false
    };
    var reset = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var resize = {
    	eventInterface: "UIEvent",
    	bubbles: false,
    	cancelable: false
    };
    var resourcetimingbufferfull = {
    	eventInterface: "Performance",
    	bubbles: true,
    	cancelable: true
    };
    var result = {
    	eventInterface: "SpeechRecognitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var resume = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var scroll = {
    	eventInterface: "UIEvent",
    	bubbles: false,
    	cancelable: false
    };
    var seeked = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var seeking = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var select = {
    	eventInterface: "UIEvent",
    	bubbles: true,
    	cancelable: false
    };
    var selectstart = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var selectionchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var show = {
    	eventInterface: "MouseEvent",
    	bubbles: false,
    	cancelable: false
    };
    var slotchange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var soundend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var soundstart = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var speechend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var speechstart = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var stalled = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var start = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var storage = {
    	eventInterface: "StorageEvent",
    	bubbles: false,
    	cancelable: false
    };
    var submit = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var success = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var suspend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var SVGAbort = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGError = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGLoad = {
    	eventInterface: "SVGEvent",
    	bubbles: false,
    	cancelable: false
    };
    var SVGResize = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGScroll = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGUnload = {
    	eventInterface: "SVGEvent",
    	bubbles: false,
    	cancelable: false
    };
    var SVGZoom = {
    	eventInterface: "SVGZoomEvent",
    	bubbles: true,
    	cancelable: false
    };
    var timeout = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var timeupdate = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var touchcancel = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: false
    };
    var touchend = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: true
    };
    var touchmove = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: true
    };
    var touchstart = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: true
    };
    var transitionend = {
    	eventInterface: "TransitionEvent",
    	bubbles: true,
    	cancelable: true
    };
    var unload = {
    	eventInterface: "UIEvent",
    	bubbles: false
    };
    var updateready = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var userproximity = {
    	eventInterface: "UserProximityEvent",
    	bubbles: false,
    	cancelable: false
    };
    var voiceschanged = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var visibilitychange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var volumechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var waiting = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var wheel = {
    	eventInterface: "WheelEvent",
    	bubbles: true,
    	cancelable: true
    };
    var domEventTypes = {
    	abort: abort,
    	afterprint: afterprint,
    	animationend: animationend,
    	animationiteration: animationiteration,
    	animationstart: animationstart,
    	appinstalled: appinstalled,
    	audioprocess: audioprocess,
    	audioend: audioend,
    	audiostart: audiostart,
    	beforeprint: beforeprint,
    	beforeunload: beforeunload,
    	beginEvent: beginEvent,
    	blur: blur,
    	boundary: boundary,
    	cached: cached,
    	canplay: canplay,
    	canplaythrough: canplaythrough,
    	change: change,
    	chargingchange: chargingchange,
    	chargingtimechange: chargingtimechange,
    	checking: checking,
    	click: click,
    	close: close,
    	complete: complete,
    	compositionend: compositionend,
    	compositionstart: compositionstart,
    	compositionupdate: compositionupdate,
    	contextmenu: contextmenu,
    	copy: copy,
    	cut: cut,
    	dblclick: dblclick,
    	devicechange: devicechange,
    	devicelight: devicelight,
    	devicemotion: devicemotion,
    	deviceorientation: deviceorientation,
    	deviceproximity: deviceproximity,
    	dischargingtimechange: dischargingtimechange,
    	DOMActivate: DOMActivate,
    	DOMAttributeNameChanged: DOMAttributeNameChanged,
    	DOMAttrModified: DOMAttrModified,
    	DOMCharacterDataModified: DOMCharacterDataModified,
    	DOMContentLoaded: DOMContentLoaded,
    	DOMElementNameChanged: DOMElementNameChanged,
    	DOMFocusIn: DOMFocusIn,
    	DOMFocusOut: DOMFocusOut,
    	DOMNodeInserted: DOMNodeInserted,
    	DOMNodeInsertedIntoDocument: DOMNodeInsertedIntoDocument,
    	DOMNodeRemoved: DOMNodeRemoved,
    	DOMNodeRemovedFromDocument: DOMNodeRemovedFromDocument,
    	DOMSubtreeModified: DOMSubtreeModified,
    	downloading: downloading,
    	drag: drag,
    	dragend: dragend,
    	dragenter: dragenter,
    	dragleave: dragleave,
    	dragover: dragover,
    	dragstart: dragstart,
    	drop: drop,
    	durationchange: durationchange,
    	emptied: emptied,
    	end: end,
    	ended: ended,
    	endEvent: endEvent,
    	error: error,
    	focus: focus,
    	focusin: focusin,
    	focusout: focusout,
    	fullscreenchange: fullscreenchange,
    	fullscreenerror: fullscreenerror,
    	gamepadconnected: gamepadconnected,
    	gamepaddisconnected: gamepaddisconnected,
    	gotpointercapture: gotpointercapture,
    	hashchange: hashchange,
    	lostpointercapture: lostpointercapture,
    	input: input,
    	invalid: invalid,
    	keydown: keydown,
    	keypress: keypress,
    	keyup: keyup,
    	languagechange: languagechange,
    	levelchange: levelchange,
    	load: load,
    	loadeddata: loadeddata,
    	loadedmetadata: loadedmetadata,
    	loadend: loadend,
    	loadstart: loadstart,
    	mark: mark,
    	message: message,
    	messageerror: messageerror,
    	mousedown: mousedown,
    	mouseenter: mouseenter,
    	mouseleave: mouseleave,
    	mousemove: mousemove,
    	mouseout: mouseout,
    	mouseover: mouseover,
    	mouseup: mouseup,
    	nomatch: nomatch,
    	notificationclick: notificationclick,
    	noupdate: noupdate,
    	obsolete: obsolete,
    	offline: offline,
    	online: online,
    	open: open,
    	orientationchange: orientationchange,
    	pagehide: pagehide,
    	pageshow: pageshow,
    	paste: paste,
    	pause: pause,
    	pointercancel: pointercancel,
    	pointerdown: pointerdown,
    	pointerenter: pointerenter,
    	pointerleave: pointerleave,
    	pointerlockchange: pointerlockchange,
    	pointerlockerror: pointerlockerror,
    	pointermove: pointermove,
    	pointerout: pointerout,
    	pointerover: pointerover,
    	pointerup: pointerup,
    	play: play,
    	playing: playing,
    	popstate: popstate,
    	progress: progress,
    	push: push,
    	pushsubscriptionchange: pushsubscriptionchange,
    	ratechange: ratechange,
    	readystatechange: readystatechange,
    	repeatEvent: repeatEvent,
    	reset: reset,
    	resize: resize,
    	resourcetimingbufferfull: resourcetimingbufferfull,
    	result: result,
    	resume: resume,
    	scroll: scroll,
    	seeked: seeked,
    	seeking: seeking,
    	select: select,
    	selectstart: selectstart,
    	selectionchange: selectionchange,
    	show: show,
    	slotchange: slotchange,
    	soundend: soundend,
    	soundstart: soundstart,
    	speechend: speechend,
    	speechstart: speechstart,
    	stalled: stalled,
    	start: start,
    	storage: storage,
    	submit: submit,
    	success: success,
    	suspend: suspend,
    	SVGAbort: SVGAbort,
    	SVGError: SVGError,
    	SVGLoad: SVGLoad,
    	SVGResize: SVGResize,
    	SVGScroll: SVGScroll,
    	SVGUnload: SVGUnload,
    	SVGZoom: SVGZoom,
    	timeout: timeout,
    	timeupdate: timeupdate,
    	touchcancel: touchcancel,
    	touchend: touchend,
    	touchmove: touchmove,
    	touchstart: touchstart,
    	transitionend: transitionend,
    	unload: unload,
    	updateready: updateready,
    	userproximity: userproximity,
    	voiceschanged: voiceschanged,
    	visibilitychange: visibilitychange,
    	volumechange: volumechange,
    	waiting: waiting,
    	wheel: wheel
    };

    var domEventTypes$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        abort: abort,
        afterprint: afterprint,
        animationend: animationend,
        animationiteration: animationiteration,
        animationstart: animationstart,
        appinstalled: appinstalled,
        audioprocess: audioprocess,
        audioend: audioend,
        audiostart: audiostart,
        beforeprint: beforeprint,
        beforeunload: beforeunload,
        beginEvent: beginEvent,
        blur: blur,
        boundary: boundary,
        cached: cached,
        canplay: canplay,
        canplaythrough: canplaythrough,
        change: change,
        chargingchange: chargingchange,
        chargingtimechange: chargingtimechange,
        checking: checking,
        click: click,
        close: close,
        complete: complete,
        compositionend: compositionend,
        compositionstart: compositionstart,
        compositionupdate: compositionupdate,
        contextmenu: contextmenu,
        copy: copy,
        cut: cut,
        dblclick: dblclick,
        devicechange: devicechange,
        devicelight: devicelight,
        devicemotion: devicemotion,
        deviceorientation: deviceorientation,
        deviceproximity: deviceproximity,
        dischargingtimechange: dischargingtimechange,
        DOMActivate: DOMActivate,
        DOMAttributeNameChanged: DOMAttributeNameChanged,
        DOMAttrModified: DOMAttrModified,
        DOMCharacterDataModified: DOMCharacterDataModified,
        DOMContentLoaded: DOMContentLoaded,
        DOMElementNameChanged: DOMElementNameChanged,
        DOMFocusIn: DOMFocusIn,
        DOMFocusOut: DOMFocusOut,
        DOMNodeInserted: DOMNodeInserted,
        DOMNodeInsertedIntoDocument: DOMNodeInsertedIntoDocument,
        DOMNodeRemoved: DOMNodeRemoved,
        DOMNodeRemovedFromDocument: DOMNodeRemovedFromDocument,
        DOMSubtreeModified: DOMSubtreeModified,
        downloading: downloading,
        drag: drag,
        dragend: dragend,
        dragenter: dragenter,
        dragleave: dragleave,
        dragover: dragover,
        dragstart: dragstart,
        drop: drop,
        durationchange: durationchange,
        emptied: emptied,
        end: end,
        ended: ended,
        endEvent: endEvent,
        error: error,
        focus: focus,
        focusin: focusin,
        focusout: focusout,
        fullscreenchange: fullscreenchange,
        fullscreenerror: fullscreenerror,
        gamepadconnected: gamepadconnected,
        gamepaddisconnected: gamepaddisconnected,
        gotpointercapture: gotpointercapture,
        hashchange: hashchange,
        lostpointercapture: lostpointercapture,
        input: input,
        invalid: invalid,
        keydown: keydown,
        keypress: keypress,
        keyup: keyup,
        languagechange: languagechange,
        levelchange: levelchange,
        load: load,
        loadeddata: loadeddata,
        loadedmetadata: loadedmetadata,
        loadend: loadend,
        loadstart: loadstart,
        mark: mark,
        message: message,
        messageerror: messageerror,
        mousedown: mousedown,
        mouseenter: mouseenter,
        mouseleave: mouseleave,
        mousemove: mousemove,
        mouseout: mouseout,
        mouseover: mouseover,
        mouseup: mouseup,
        nomatch: nomatch,
        notificationclick: notificationclick,
        noupdate: noupdate,
        obsolete: obsolete,
        offline: offline,
        online: online,
        open: open,
        orientationchange: orientationchange,
        pagehide: pagehide,
        pageshow: pageshow,
        paste: paste,
        pause: pause,
        pointercancel: pointercancel,
        pointerdown: pointerdown,
        pointerenter: pointerenter,
        pointerleave: pointerleave,
        pointerlockchange: pointerlockchange,
        pointerlockerror: pointerlockerror,
        pointermove: pointermove,
        pointerout: pointerout,
        pointerover: pointerover,
        pointerup: pointerup,
        play: play,
        playing: playing,
        popstate: popstate,
        progress: progress,
        push: push,
        pushsubscriptionchange: pushsubscriptionchange,
        ratechange: ratechange,
        readystatechange: readystatechange,
        repeatEvent: repeatEvent,
        reset: reset,
        resize: resize,
        resourcetimingbufferfull: resourcetimingbufferfull,
        result: result,
        resume: resume,
        scroll: scroll,
        seeked: seeked,
        seeking: seeking,
        select: select,
        selectstart: selectstart,
        selectionchange: selectionchange,
        show: show,
        slotchange: slotchange,
        soundend: soundend,
        soundstart: soundstart,
        speechend: speechend,
        speechstart: speechstart,
        stalled: stalled,
        start: start,
        storage: storage,
        submit: submit,
        success: success,
        suspend: suspend,
        SVGAbort: SVGAbort,
        SVGError: SVGError,
        SVGLoad: SVGLoad,
        SVGResize: SVGResize,
        SVGScroll: SVGScroll,
        SVGUnload: SVGUnload,
        SVGZoom: SVGZoom,
        timeout: timeout,
        timeupdate: timeupdate,
        touchcancel: touchcancel,
        touchend: touchend,
        touchmove: touchmove,
        touchstart: touchstart,
        transitionend: transitionend,
        unload: unload,
        updateready: updateready,
        userproximity: userproximity,
        voiceschanged: voiceschanged,
        visibilitychange: visibilitychange,
        volumechange: volumechange,
        waiting: waiting,
        wheel: wheel,
        'default': domEventTypes
    });

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var require$$0 = getCjsExportFromNamespace(domEventTypes$1);

    var domEventTypes$2 = require$$0;

    var keyCodesByKeyName = {
        backspace: 8,
        tab: 9,
        enter: 13,
        esc: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        insert: 45,
        delete: 46
    };
    function getEventProperties(eventParams) {
        var modifier = eventParams.modifier, meta = eventParams.meta, options = eventParams.options;
        var keyCode = keyCodesByKeyName[modifier] ||
            (options && (options.keyCode || options.code));
        return __assign(__assign({}, options), { bubbles: meta.bubbles, meta: meta.cancelable, 
            // Any derived options should go here
            keyCode: keyCode, code: keyCode });
    }
    function createEvent(eventParams) {
        var eventType = eventParams.eventType, meta = eventParams.meta;
        var metaEventInterface = window[meta.eventInterface];
        var SupportedEventInterface = typeof metaEventInterface === 'function' ? metaEventInterface : window.Event;
        var eventProperties = getEventProperties(eventParams);
        var event = new SupportedEventInterface(eventType, 
        // event properties can only be added when the event is instantiated
        // custom properties must be added after the event has been instantiated
        eventProperties);
        return event;
    }
    function createDOMEvent(eventString, options) {
        var _a = eventString.split('.'), eventType = _a[0], modifier = _a[1];
        var meta = domEventTypes$2[eventType] || {
            eventInterface: 'Event',
            cancelable: true,
            bubbles: true
        };
        var eventParams = { eventType: eventType, modifier: modifier, meta: meta, options: options };
        var event = createEvent(eventParams);
        var eventPrototype = Object.getPrototypeOf(event);
        options &&
            Object.keys(options).forEach(function (key) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(eventPrototype, key);
                var canSetProperty = !(propertyDescriptor && propertyDescriptor.set === undefined);
                if (canSetProperty) {
                    event[key] = options[key];
                }
            });
        return event;
    }

    var DOMWrapper = /** @class */ (function () {
        function DOMWrapper(element) {
            this.element = element;
        }
        DOMWrapper.prototype.classes = function (className) {
            var classes = this.element.classList;
            if (className)
                return classes.contains(className);
            return Array.from(classes);
        };
        DOMWrapper.prototype.attributes = function (key) {
            var attributes = this.element.attributes;
            var attributeMap = {};
            for (var i = 0; i < attributes.length; i++) {
                var att = attributes.item(i);
                attributeMap[att.localName] = att.value;
            }
            return key ? attributeMap[key] : attributeMap;
        };
        DOMWrapper.prototype.exists = function () {
            return true;
        };
        DOMWrapper.prototype.text = function () {
            var _a;
            return (_a = this.element.textContent) === null || _a === void 0 ? void 0 : _a.trim();
        };
        DOMWrapper.prototype.html = function () {
            return this.element.outerHTML;
        };
        DOMWrapper.prototype.find = function (selector) {
            var result = this.element.querySelector(selector);
            if (result) {
                return new DOMWrapper(result);
            }
            return createWrapperError('DOMWrapper');
        };
        DOMWrapper.prototype.get = function (selector) {
            var result = this.find(selector);
            if (result instanceof DOMWrapper) {
                return result;
            }
            throw new Error("Unable to get " + selector + " within: " + this.html());
        };
        DOMWrapper.prototype.findAll = function (selector) {
            return Array.from(this.element.querySelectorAll(selector)).map(function (x) { return new DOMWrapper(x); });
        };
        DOMWrapper.prototype.setChecked = function (checked) {
            if (checked === void 0) { checked = true; }
            return __awaiter(this, void 0, void 0, function () {
                var element, type;
                return __generator(this, function (_a) {
                    element = this.element;
                    type = this.attributes().type;
                    if (type === 'radio' && !checked) {
                        throw Error("wrapper.setChecked() cannot be called with parameter false on a '<input type=\"radio\" /> element.");
                    }
                    // we do not want to trigger an event if the user
                    // attempting set the same value twice
                    // this is because in a browser setting checked = true when it is
                    // already true is a no-op; no change event is triggered
                    if (checked === element.checked) {
                        return [2 /*return*/];
                    }
                    element.checked = checked;
                    return [2 /*return*/, this.trigger('change')];
                });
            });
        };
        DOMWrapper.prototype.setValue = function (value) {
            var element = this.element;
            var tagName = element.tagName;
            var type = this.attributes().type;
            if (tagName === 'OPTION') {
                return this.setSelected();
            }
            else if (tagName === 'INPUT' && type === 'checkbox') {
                return this.setChecked(value);
            }
            else if (tagName === 'INPUT' && type === 'radio') {
                return this.setChecked(value);
            }
            else if (tagName === 'INPUT' ||
                tagName === 'TEXTAREA' ||
                tagName === 'SELECT') {
                element.value = value;
                if (tagName === 'SELECT') {
                    return this.trigger('change');
                }
                this.trigger('input');
                // trigger `change` for `v-model.lazy`
                return this.trigger('change');
            }
            else {
                throw Error("wrapper.setValue() cannot be called on " + tagName);
            }
        };
        DOMWrapper.prototype.setSelected = function () {
            var element = this.element;
            if (element.selected) {
                return;
            }
            element.selected = true;
            var parentElement = element.parentElement;
            if (parentElement.tagName === 'OPTGROUP') {
                parentElement = parentElement.parentElement;
            }
            return new DOMWrapper(parentElement).trigger('change');
        };
        DOMWrapper.prototype.trigger = function (eventString, options) {
            return __awaiter(this, void 0, void 0, function () {
                var isDisabled, event_1;
                var _this = this;
                return __generator(this, function (_a) {
                    if (options && options['target']) {
                        throw Error("[vue-test-utils]: you cannot set the target value of an event. See the notes section " +
                            "of the docs for more details\u2014" +
                            "https://vue-test-utils.vuejs.org/api/wrapper/trigger.html");
                    }
                    isDisabled = function () {
                        var validTagsToBeDisabled = [
                            'BUTTON',
                            'COMMAND',
                            'FIELDSET',
                            'KEYGEN',
                            'OPTGROUP',
                            'OPTION',
                            'SELECT',
                            'TEXTAREA',
                            'INPUT'
                        ];
                        var hasDisabledAttribute = _this.attributes().disabled !== undefined;
                        var elementCanBeDisabled = validTagsToBeDisabled.includes(_this.element.tagName);
                        return hasDisabledAttribute && elementCanBeDisabled;
                    };
                    if (this.element && !isDisabled()) {
                        event_1 = createDOMEvent(eventString, options);
                        this.element.dispatchEvent(event_1);
                    }
                    return [2 /*return*/, vue.nextTick];
                });
            });
        };
        return DOMWrapper;
    }());

    var cacheStringFunction = function (fn) {
        var cache = Object.create(null);
        return (function (str) {
            var hit = cache[str];
            return hit || (cache[str] = fn(str));
        });
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction(function (str) {
        return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
    });
    var capitalize = cacheStringFunction(function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction(function (str) {
        return str.replace(hyphenateRE, '-$1').toLowerCase();
    });

    function matchName(target, sourceName) {
        var camelized = camelize(target);
        var capitalized = capitalize(camelized);
        return (sourceName &&
            (sourceName === target ||
                sourceName === camelized ||
                sourceName === capitalized ||
                capitalize(camelize(sourceName)) === capitalized));
    }

    /**
     * Detect whether a selector matches a VNode
     * @param node
     * @param selector
     * @return {boolean | ((value: any) => boolean)}
     */
    function matches(node, selector) {
        var _a, _b;
        // do not return none Vue components
        if (!node.component)
            return false;
        if (typeof selector === 'string') {
            return (_b = (_a = node.el) === null || _a === void 0 ? void 0 : _a.matches) === null || _b === void 0 ? void 0 : _b.call(_a, selector);
        }
        if (typeof selector === 'object' && typeof node.type === 'object') {
            if (selector === node.type)
                return true;
            if (selector.name && ('name' in node.type || 'displayName' in node.type)) {
                // match normal component definitions or functional components
                return matchName(selector.name, node.type.name || node.type.displayName);
            }
        }
        return false;
    }
    /**
     * Collect all children
     * @param nodes
     * @param children
     */
    function aggregateChildren(nodes, children) {
        if (children && Array.isArray(children)) {
            __spreadArrays(children).reverse().forEach(function (n) {
                nodes.unshift(n);
            });
        }
    }
    function findAllVNodes(vnode, selector) {
        var _a;
        var matchingNodes = [];
        var nodes = [vnode];
        while (nodes.length) {
            var node = nodes.shift();
            aggregateChildren(nodes, node.children);
            aggregateChildren(nodes, (_a = node.component) === null || _a === void 0 ? void 0 : _a.subTree.children);
            if (matches(node, selector)) {
                matchingNodes.push(node);
            }
        }
        return matchingNodes;
    }
    function find(root, selector) {
        return findAllVNodes(root, selector).map(function (vnode) { return vnode.component.proxy; });
    }

    var VueWrapper = /** @class */ (function () {
        function VueWrapper(app, vm, setProps) {
            this.__app = app;
            this.rootVM = vm.$root;
            this.componentVM = vm;
            this.__setProps = setProps;
            // plugins hook
            config.plugins.VueWrapper.extend(this);
        }
        Object.defineProperty(VueWrapper.prototype, "hasMultipleRoots", {
            get: function () {
                // if the subtree is an array of children, we have multiple root nodes
                return this.vm.$.subTree.shapeFlag === 16 /* ARRAY_CHILDREN */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VueWrapper.prototype, "parentElement", {
            get: function () {
                return this.vm.$el.parentElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VueWrapper.prototype, "element", {
            get: function () {
                // if the component has multiple root elements, we use the parent's element
                return this.hasMultipleRoots ? this.parentElement : this.vm.$el;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VueWrapper.prototype, "vm", {
            get: function () {
                return this.componentVM;
            },
            enumerable: true,
            configurable: true
        });
        VueWrapper.prototype.props = function (selector) {
            var props = this.componentVM.$props;
            return selector ? props[selector] : props;
        };
        VueWrapper.prototype.classes = function (className) {
            return new DOMWrapper(this.element).classes(className);
        };
        VueWrapper.prototype.attributes = function (key) {
            return new DOMWrapper(this.element).attributes(key);
        };
        VueWrapper.prototype.exists = function () {
            return true;
        };
        VueWrapper.prototype.emitted = function () {
            // TODO Should we define this?
            // @ts-ignore
            return this.vm.__emitted;
        };
        VueWrapper.prototype.html = function () {
            return this.parentElement.innerHTML;
        };
        VueWrapper.prototype.text = function () {
            var _a;
            return (_a = this.element.textContent) === null || _a === void 0 ? void 0 : _a.trim();
        };
        VueWrapper.prototype.find = function (selector) {
            // force using the parentElement to allow finding the root element
            var result = this.parentElement.querySelector(selector);
            if (result) {
                return new DOMWrapper(result);
            }
            return createWrapperError('DOMWrapper');
        };
        VueWrapper.prototype.get = function (selector) {
            var result = this.find(selector);
            if (result instanceof DOMWrapper) {
                return result;
            }
            throw new Error("Unable to get " + selector + " within: " + this.html());
        };
        VueWrapper.prototype.findComponent = function (selector) {
            if (typeof selector === 'object' && 'ref' in selector) {
                var result_1 = this.vm.$refs[selector.ref];
                if (result_1) {
                    return createWrapper(null, result_1);
                }
            }
            var result = find(this.vm.$.subTree, selector);
            if (result.length) {
                return createWrapper(null, result[0]);
            }
            return createWrapperError('VueWrapper');
        };
        VueWrapper.prototype.getComponent = function (selector) {
            var result = this.findComponent(selector);
            if (result instanceof VueWrapper) {
                return result;
            }
            var message = 'Unable to get ';
            if (typeof selector === 'string') {
                message += "component with selector " + selector;
            }
            else if (selector.name) {
                message += "component with name " + selector.name;
            }
            else if (selector.ref) {
                message += "component with ref " + selector.ref;
            }
            else {
                message += 'specified component';
            }
            message += " within: " + this.html();
            throw new Error(message);
        };
        VueWrapper.prototype.findAllComponents = function (selector) {
            return find(this.vm.$.subTree, selector).map(function (c) { return createWrapper(null, c); });
        };
        VueWrapper.prototype.findAll = function (selector) {
            var results = this.parentElement.querySelectorAll(selector);
            return Array.from(results).map(function (element) { return new DOMWrapper(element); });
        };
        VueWrapper.prototype.setProps = function (props) {
            // if this VM's parent is not the root or if setProps does not exist, error out
            if (this.vm.$parent !== this.rootVM || !this.__setProps) {
                throw Error('You can only use setProps on your mounted component');
            }
            this.__setProps(props);
            return vue.nextTick();
        };
        VueWrapper.prototype.trigger = function (eventString, options) {
            var rootElementWrapper = new DOMWrapper(this.element);
            return rootElementWrapper.trigger(eventString, options);
        };
        VueWrapper.prototype.unmount = function () {
            // preventing dispose of child component
            if (!this.__app) {
                throw new Error("wrapper.unmount() can only be called by the root wrapper");
            }
            if (this.parentElement) {
                this.parentElement.removeChild(this.element);
            }
            this.__app.unmount(this.element);
        };
        return VueWrapper;
    }());
    function createWrapper(app, vm, setProps) {
        return new VueWrapper(app, vm, setProps);
    }

    var attachEmitListener = function () {
        return {
            beforeCreate: function () {
                var events = {};
                this.__emitted = events;
                var originalEmit = vue.getCurrentInstance().emit;
                vue.getCurrentInstance().emit = function (event) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    events[event]
                        ? (events[event] = __spreadArrays(events[event], [__spreadArrays(args)]))
                        : (events[event] = [__spreadArrays(args)]);
                    originalEmit.apply(void 0, __spreadArrays([event], args));
                    return __spreadArrays([event], args);
                };
            }
        };
    };

    var createDataMixin = function (data) {
        return {
            created: function () {
                var _a;
                for (var _i = 0, _b = Object.entries(data); _i < _b.length; _i++) {
                    var _c = _b[_i], k = _c[0], v = _c[1];
                    vue.getCurrentInstance().data = __assign(__assign({}, vue.getCurrentInstance().data), (_a = {}, _a[k] = v, _a));
                }
            }
        };
    };

    var MOUNT_ELEMENT_ID = 'app';
    var MOUNT_COMPONENT_REF = 'VTU_COMPONENT';
    var MOUNT_PARENT_NAME = 'VTU_ROOT';

    function getSlots(ctx) {
        return !config.renderStubDefaultSlot ? undefined : ctx.$slots;
    }
    var createStub = function (_a) {
        var name = _a.name, props = _a.props;
        var anonName = 'anonymous-stub';
        var tag = name ? hyphenate(name) + "-stub" : anonName;
        var render = function (ctx) {
            return vue.h(tag, {}, getSlots(ctx));
        };
        return { name: name || anonName, render: render, props: props };
    };
    var resolveComponentStubByName = function (componentName, stubs) {
        if (Array.isArray(stubs) && stubs.length) {
            // ['Foo', 'Bar'] => { Foo: true, Bar: true }
            stubs = stubs.reduce(function (acc, current) {
                acc[current] = true;
                return acc;
            }, {});
        }
        for (var _i = 0, _a = Object.entries(stubs); _i < _a.length; _i++) {
            var _b = _a[_i], stubKey = _b[0], value = _b[1];
            if (matchName(componentName, stubKey)) {
                return value;
            }
        }
    };
    var isHTMLElement = function (args) { return typeof args[0] === 'string'; };
    var isCommentOrFragment = function (args) { return typeof args[0] === 'symbol'; };
    var isParent = function (args) {
        return isComponent(args) && args[0]['name'] === MOUNT_PARENT_NAME;
    };
    var isMountedComponent = function (args) {
        return isComponent(args) && args[1] && args[1]['ref'] === MOUNT_COMPONENT_REF;
    };
    var isComponent = function (args) { return typeof args[0] === 'object'; };
    var isFunctionalComponent = function (_a) {
        var type = _a[0];
        return typeof type === 'function' && ('name' in type || 'displayName' in type);
    };
    function stubComponents(stubs, shallow) {
        if (stubs === void 0) { stubs = {}; }
        if (shallow === void 0) { shallow = false; }
        vue.transformVNodeArgs(function (args) {
            // args[0] can either be:
            // 1. a HTML tag (div, span...)
            // 2. An object of component options, such as { name: 'foo', render: [Function], props: {...} }
            // Depending what it is, we do different things.
            if (isHTMLElement(args) ||
                isCommentOrFragment(args) ||
                isParent(args) ||
                isMountedComponent(args)) {
                return args;
            }
            if (isComponent(args) || isFunctionalComponent(args)) {
                var type = args[0], props = args[1], children = args[2], patchFlag = args[3], dynamicProps = args[4];
                var name_1 = type['name'] || type['displayName'];
                if (!name_1 && !shallow) {
                    return args;
                }
                var stub = resolveComponentStubByName(name_1, stubs);
                // case 2: custom implementation
                if (typeof stub === 'object') {
                    // pass the props and children, for advanced stubbing
                    return [stubs[name_1], props, children, patchFlag, dynamicProps];
                }
                // we return a stub by matching Vue's `h` function
                // where the signature is h(Component, props, slots)
                // case 1: default stub
                if (stub === true || shallow) {
                    // @ts-ignore
                    var propsDeclaration = (type === null || type === void 0 ? void 0 : type.props) || {};
                    return [
                        createStub({ name: name_1, props: propsDeclaration }),
                        props,
                        children,
                        patchFlag,
                        dynamicProps
                    ];
                }
            }
            return args;
        });
    }

    function mount(originalComponent, options) {
        // normalise the incoming component
        var component = typeof originalComponent === 'function'
            ? {
                setup: function (_, _a) {
                    var attrs = _a.attrs, slots = _a.slots;
                    return function () {
                        return vue.h(originalComponent, attrs, slots);
                    };
                }
            }
            : __assign({}, originalComponent);
        var el = document.createElement('div');
        el.id = MOUNT_ELEMENT_ID;
        if (options === null || options === void 0 ? void 0 : options.attachTo) {
            var to = void 0;
            if (typeof options.attachTo === 'string') {
                to = document.querySelector(options.attachTo);
                if (!to) {
                    throw new Error("Unable to find the element matching the selector " + options.attachTo + " given as the `attachTo` option");
                }
            }
            else {
                to = options.attachTo;
            }
            to.appendChild(el);
        }
        // handle any slots passed via mounting options
        var slots = (options === null || options === void 0 ? void 0 : options.slots) &&
            Object.entries(options.slots).reduce(function (acc, _a) {
                var name = _a[0], slot = _a[1];
                // case of an SFC getting passed
                if (typeof slot === 'object' && 'render' in slot) {
                    acc[name] = slot.render;
                    return acc;
                }
                if (typeof slot === 'function') {
                    acc[name] = slot;
                    return acc;
                }
                if (typeof slot === 'object') {
                    acc[name] = function () { return slot; };
                    return acc;
                }
                if (typeof slot === 'string') {
                    // slot is most probably a scoped slot string or a plain string
                    acc[name] = function (props) { return vue.h(processSlot(slot), props); };
                    return acc;
                }
            }, {});
        // override component data with mounting options data
        if (options === null || options === void 0 ? void 0 : options.data) {
            var dataMixin = createDataMixin(options.data());
            component.mixins = __spreadArrays((component.mixins || []), [
                dataMixin
            ]);
        }
        // we define props as reactive so that way when we update them with `setProps`
        // Vue's reactivity system will cause a rerender.
        var props = vue.reactive(__assign(__assign(__assign({}, options === null || options === void 0 ? void 0 : options.attrs), options === null || options === void 0 ? void 0 : options.props), { ref: MOUNT_COMPONENT_REF }));
        var global = mergeGlobalProperties(config.global, options === null || options === void 0 ? void 0 : options.global);
        component.components = __assign(__assign({}, component.components), global.components);
        // create the wrapper component
        var Parent = vue.defineComponent({
            name: MOUNT_PARENT_NAME,
            render: function () {
                return vue.h(component, props, slots);
            }
        });
        var setProps = function (newProps) {
            for (var _i = 0, _a = Object.entries(newProps); _i < _a.length; _i++) {
                var _b = _a[_i], k = _b[0], v = _b[1];
                props[k] = v;
            }
            return vm.$nextTick();
        };
        // create the app
        var app = vue.createApp(Parent);
        // global mocks mixin
        if (global === null || global === void 0 ? void 0 : global.mocks) {
            var mixin = {
                beforeCreate: function () {
                    for (var _i = 0, _a = Object.entries(global.mocks); _i < _a.length; _i++) {
                        var _b = _a[_i], k = _b[0], v = _b[1];
                        this[k] = v;
                    }
                }
            };
            app.mixin(mixin);
        }
        // AppConfig
        if (global.config) {
            for (var _i = 0, _a = Object.entries(global.config); _i < _a.length; _i++) {
                var _b = _a[_i], k = _b[0], v = _b[1];
                app.config[k] = v;
            }
        }
        // use and plugins from mounting options
        if (global.plugins) {
            for (var _c = 0, _d = global.plugins; _c < _d.length; _c++) {
                var use = _d[_c];
                app.use(use);
            }
        }
        // use any mixins from mounting options
        if (global.mixins) {
            for (var _e = 0, _f = global.mixins; _e < _f.length; _e++) {
                var mixin = _f[_e];
                app.mixin(mixin);
            }
        }
        if (global.components) {
            for (var _g = 0, _h = Object.keys(global.components); _g < _h.length; _g++) {
                var key = _h[_g];
                app.component(key, global.components[key]);
            }
        }
        if (global.directives) {
            for (var _j = 0, _k = Object.keys(global.directives); _j < _k.length; _j++) {
                var key = _k[_j];
                app.directive(key, global.directives[key]);
            }
        }
        // provide any values passed via provides mounting option
        if (global.provide) {
            for (var _l = 0, _m = Reflect.ownKeys(global.provide); _l < _m.length; _l++) {
                var key = _m[_l];
                // @ts-ignore: https://github.com/microsoft/TypeScript/issues/1863
                app.provide(key, global.provide[key]);
            }
        }
        // add tracking for emitted events
        app.mixin(attachEmitListener());
        // stubs
        if (global.stubs || (options === null || options === void 0 ? void 0 : options.shallow)) {
            stubComponents(global.stubs, options === null || options === void 0 ? void 0 : options.shallow);
        }
        else {
            vue.transformVNodeArgs();
        }
        // mount the app!
        var vm = app.mount(el);
        var App = vm.$refs[MOUNT_COMPONENT_REF];
        return createWrapper(app, App, setProps);
    }
    function shallowMount(originalComponent, options) {
        return mount(originalComponent, __assign(__assign({}, options), { shallow: true }));
    }

    // TODO: Borrow typings from vue-router-next
    var RouterLinkStub = vue.defineComponent({
        name: 'RouterLinkStub',
        props: {
            to: {
                type: [String, Object],
                required: true
            }
        },
        render: function () {
            return vue.h('a', undefined, this.$slots.default());
        }
    });

    exports.DOMWrapper = DOMWrapper;
    exports.RouterLinkStub = RouterLinkStub;
    exports.VueWrapper = VueWrapper;
    exports.config = config;
    exports.mount = mount;
    exports.shallowMount = shallowMount;

    return exports;

}({}, Vue, VueCompilerDOM));
